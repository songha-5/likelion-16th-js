// --------------------------------------------------------------------------
// 실습: 실행 컨텍스트 (Execution Context)
// --------------------------------------------------------------------------
// * 실행 컨텍스트 : JavaScript 코드가 실행되는 환경(작업대)입니다.
// * 전역 컨텍스트 : 프로그램 시작 시 생성되는 기본 작업대입니다.
// * 함수 컨텍스트 : 함수 호출 시마다 생성되는 임시 작업대입니다.
// * 2단계 실행 : 1. 메모리 생성(준비) → 2. 코드 실행(할당) 순서로 진행됩니다.
// --------------------------------------------------------------------------


// --------------------------------------------------------------------------
// 전역 실행 컨텍스트 - 기본 예제
// --------------------------------------------------------------------------

// 전역 변수 선언
// restaurantName 변수에 '이탈리안 키친' 할당
const restaurantName = '이탈리안 키친'
// isOpen 변수에 true 할당
const isOpen = true


// 전역 변수 출력
console.log('restaurantName:', restaurantName)
console.log('isOpen', isOpen)
// 설명:
// 브라우저가 JavaScript 파일을 로드하면 전역 실행 컨텍스트가 생성됩니다.
// 전역 변수는 프로그램이 종료될 때까지 메모리에 유지됩니다.

// 출력 결과:
// '이탈리안 키친'
// true


// --------------------------------------------------------------------------
// 함수 실행 컨텍스트 - 기본 예제
// --------------------------------------------------------------------------

// makePasta 함수 선언
// 매개변수: pastaType
function makePasta(pastaType) {
  return pastaType + ' pastaType'
}
// 기능: '[pastaType] 파스타를 만들고 있습니다.' 출력
console.log(makePasta('[pastaType]'))

// makePasta 함수 호출 ('까르보나라' 전달)
console.log(makePasta('까르보나라'))

// makePasta 함수 호출 ('알리오 올리오' 전달)
console.log(makePasta('알리오 올리오'))


// 설명:
// 함수가 호출될 때마다 새로운 함수 실행 컨텍스트가 생성됩니다.
// 함수 실행이 끝나면 해당 컨텍스트는 메모리에서 삭제됩니다.

// 출력 결과:
// '까르보나라 파스타를 만들고 있습니다.'
// '알리오 올리오 파스타를 만들고 있습니다.'


// --------------------------------------------------------------------------
// 실행 컨텍스트 작동 원리 - 1단계: 메모리 생성
// --------------------------------------------------------------------------

// 아래 코드의 실행 과정을 단계별로 분석해봅니다.

// [1단계: 메모리 생성 - 전역 컨텍스트]
// JavaScript 엔진이 코드를 훑으며 변수와 함수를 메모리에 등록합니다.
// - menuPrice : <Uninitialized> (TDZ 진입)
// - discount : <Uninitialized> (TDZ 진입)
// - calculatePrice : { function code... } (함수는 바로 사용 가능)
// - finalPrice : <Uninitialized> (TDZ 진입)

// menuPrice 변수에 50000 할당
const menuPrice = 50_000

// discount 변수에 0.1 할당
const discount = 0.1

// calculatePrice 함수 선언
// 매개변수: price, discountRate
// 기능: price에서 할인을 적용한 금액을 계산하여 반환
// 지역 변수 discountedPrice 사용
function calculatePrice(price, discountRate) {

}

// finalPrice 변수에 calculatePrice 함수 호출 결과 할당 (menuPrice, discount 전달)


// finalPrice 출력


// 설명:
// 1단계(메모리 생성)에서 변수는 등록되지만 초기화되지 않습니다. (TDZ)
// 함수 선언은 전체 코드가 메모리에 저장되어 바로 사용 가능합니다.

// 출력 결과:
// 45000


// --------------------------------------------------------------------------
// 실행 컨텍스트 작동 원리 - 2단계: 코드 실행
// --------------------------------------------------------------------------

// [2단계: 코드 실행 - 전역 컨텍스트]
// 코드를 한 줄씩 실행하며 값을 할당합니다.
// - menuPrice = 50000 (TDZ 해제)
// - discount = 0.1 (TDZ 해제)
// - calculatePrice(50000, 0.1) 호출 → 함수 컨텍스트 생성

// [함수 컨텍스트 - 메모리 생성]
// - price : 50000 (매개변수는 바로 초기화)
// - discountRate : 0.1 (매개변수는 바로 초기화)
// - discountedPrice : <Uninitialized> (TDZ 진입)

// [함수 컨텍스트 - 코드 실행]
// - discountedPrice = 50000 - (50000 * 0.1) = 45000 (TDZ 해제)
// - return 45000
// - 함수 컨텍스트 종료 (메모리 삭제)

// [다시 전역 컨텍스트]
// - finalPrice = 45000 (TDZ 해제)


// --------------------------------------------------------------------------
// 호이스팅 확인하기
// --------------------------------------------------------------------------

// 함수 선언은 호이스팅되어 선언 전에 호출 가능
// greet 함수 호출 ('손님' 전달)


// greet 함수 선언
// 매개변수: name
// 기능: '어서오세요, [name]님!' 반환


// 설명:
// 함수 선언은 메모리 생성 단계에서 전체 코드가 저장되므로
// 선언 전에 호출해도 정상 작동합니다. (호이스팅)

// 출력 결과:
// '어서오세요, 손님님!'


// --------------------------------------------------------------------------
// TDZ (Temporal Dead Zone) 확인하기
// --------------------------------------------------------------------------

// 아래 코드의 주석을 해제하면 ReferenceError 발생
// console.log(dishName) // ReferenceError: Cannot access 'dishName' before initialization

// dishName 변수에 '라자냐' 할당


// dishName 출력


// 설명:
// let, const로 선언된 변수는 메모리에 등록되지만 초기화되지 않습니다.
// 선언문을 만나기 전까지 TDZ(일시적 사각지대)에 있어 접근할 수 없습니다.

// 출력 결과:
// '라자냐'


// --------------------------------------------------------------------------
// 스코프 체인 (Scope Chain)
// --------------------------------------------------------------------------

// 설명:
// 내부 함수(serveDish)는 자신의 스코프에 없는 변수를 찾을 때
// 외부 함수(cookDish)와 전역 스코프를 차례로 확인합니다.
// 이를 스코프 체인이라고 합니다.

// 출력 결과:
// '김셰프님이 스파게티를 30분만에 완성했습니다!'

// 전역 변수 선언
// chefName 변수에 '김셰프' 할당
const chefName = '김셰프'

// cookDish 함수 선언
// 매개변수: dish
// 기능: 
//   - 지역 변수 cookingTime에 30 할당
//   - serveDish 함수 선언 (내부 함수)
//     - 기능: '[chefName]님이 [dish]를 [cookingTime]분만에 완성했습니다!' 출력
//   - serveDish 함수 호출
function cookDish(dish) {
  const cookingTime = 30

  function serveDish() {
    // return '[chefName]님이 [dish]를 [cookingTime]분만에 완성했습니다!'
    let message = chefName
        message += '님이 '
        message += dish
        message += '를 '
        message += cookingTime
        message += '분만에 완성했습니다!'
    
    return message
  }

  console.log(serveDish())

  // 암묵적 반환
  // return undefined
}

// cookDish 함수 호출 ('스파게티' 전달)
console.log(cookDish('스파게티'))
// --------------------------------------------------------------------------
// 복잡한 실행 컨텍스트 흐름
// --------------------------------------------------------------------------

// x 변수에 100 할당


// y 변수에 50 할당


// getSum 함수 선언
// 매개변수: n1, n2
// 기능:
//   - 지역 변수 sum에 n1 + n2 할당
//   - sum 반환


// result 변수에 getSum 함수 호출 결과 할당 (x, y 전달)


// result 출력


// 설명:
// 실행 흐름:
// 1. 전역 컨텍스트 생성 → x, y, getSum, result 메모리 등록
// 2. x = 100, y = 50 할당
// 3. getSum(100, 50) 호출 → 함수 컨텍스트 생성
// 4. 함수 내부: sum = 150 계산 및 반환
// 5. 함수 컨텍스트 종료
// 6. result = 150 할당

// 출력 결과:
// 150


// --------------------------------------------------------------------------
// 핵심!
// --------------------------------------------------------------------------
// 1. 실행 컨텍스트는 코드가 실행되는 환경(작업대)입니다.
// 2. 전역 컨텍스트는 프로그램 시작 시, 함수 컨텍스트는 함수 호출 시 생성됩니다.
// 3. 실행은 1. 메모리 생성(준비) → 2. 코드 실행(할당) 순서로 진행됩니다.
// 4. let, const 변수는 메모리 생성 단계에서 등록되지만 초기화되지 않습니다. (TDZ)
// 5. 함수 선언은 메모리 생성 단계에서 전체 코드가 저장되어 바로 사용 가능합니다. (호이스팅)
// 6. 스코프 체인 덕분에 내부 함수에서 외부 변수를 참조할 수 있습니다.


// --------------------------------------------------------------------------
// 추가 연습 예제
// --------------------------------------------------------------------------

// 전역 변수 선언
// restaurantType 변수에 '이탈리안' 할당


// orderFood 함수 선언
// 매개변수: foodName, quantity
// 기능:
//   - 지역 변수 totalPrice에 quantity * 15000 할당
//   - printReceipt 함수 선언 (내부 함수)
//     - 기능: '[restaurantType] 레스토랑 - [foodName] [quantity]개 주문, 총 [totalPrice]원' 출력
//   - printReceipt 함수 호출


// orderFood 함수 호출 ('피자', 2 전달)


// 설명:
// 이 예제는 전역 컨텍스트, 함수 컨텍스트, 스코프 체인을 모두 포함합니다.
// printReceipt는 자신의 외부 함수와 전역 스코프의 변수를 모두 참조합니다.

// 출력 결과:
// '이탈리안 레스토랑 - 피자 2개 주문, 총 30000원'


// 실습 문제
// const discountRate => TDZ
// function => 코드가 다 올라가 사용할 수 있는 상태
// 2. 레퍼런스 에러