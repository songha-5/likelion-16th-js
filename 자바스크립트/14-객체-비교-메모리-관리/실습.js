// --------------------------------------------------------------------------
// 실습: 객체 비교와 메모리 관리
// --------------------------------------------------------------------------
// * 기본 타입 : 스택(Stack)에 값 자체가 저장됩니다. (값 복사)
// * 객체 타입 : 힙(Heap)에 저장되고, 스택에는 주소만 저장됩니다. (주소 복사)
// * 동치 비교(===) : 스택에 저장된 값을 비교합니다.
// * 객체 비교 : 주소(참조)가 같아야 true, 내용이 같아도 주소가 다르면 false
// --------------------------------------------------------------------------


// --------------------------------------------------------------------------
// 동치 vs 동등 연산자
// --------------------------------------------------------------------------

// 엄격한 동치 (===) - 값과 타입이 모두 같아야 참

// 24 === 24 결과 출력


// '24' === 24 결과 출력 (타입이 다름)


// 느슨한 동치 (==) - 값만 같으면 참 (타입 자동 변환)

// '24' == 24 결과 출력 (문자열이 숫자로 자동 변환)


// 설명:
// === 연산자는 타입과 값을 모두 비교합니다. (동치, Identical)
// == 연산자는 타입을 자동 변환한 후 값만 비교합니다. (동등, Equality)

// 출력 결과:
// true
// false
// true


// --------------------------------------------------------------------------
// 객체 비교의 미스터리
// --------------------------------------------------------------------------

// 야무 객체 생성
// isHavingFun 속성: true


// 지니 객체 생성
// isHavingFun 속성: true


// 야무와 지니를 === 연산자로 비교한 결과 출력


// 설명:
// 두 객체의 내용은 같지만, 메모리의 서로 다른 위치에 저장되어 있습니다.
// === 연산자는 객체의 주소(참조)를 비교하므로 false가 반환됩니다.

// 출력 결과:
// false


// --------------------------------------------------------------------------
// 기본 타입 저장 방식 (Stack) - 값 복사
// --------------------------------------------------------------------------

// name 변수에 '네무' 할당


// new_name 변수에 name 값 복사


// new_name 변수를 '야무'로 변경


// name 변수 출력


// new_name 변수 출력


// 설명:
// 기본 타입은 스택(Stack)에 값 자체가 저장됩니다.
// 변수를 복사하면 값이 새로운 메모리 공간에 복사되어 서로 독립적입니다.

// 출력 결과:
// '네무' (원본 값은 변경되지 않음)
// '야무'


// --------------------------------------------------------------------------
// 객체 타입 저장 방식 (Heap) - 주소 복사
// --------------------------------------------------------------------------

// person 객체 생성
// name 속성: '성준일'
// age 속성: 57


// new_person 변수에 person 객체 할당 (주소 복사)


// new_person 객체의 age 속성을 21로 변경


// person 객체의 age 속성 출력


// new_person 객체의 age 속성 출력


// 설명:
// 객체는 힙(Heap)에 저장되고, 스택에는 주소(참조)만 저장됩니다.
// 변수를 복사하면 주소가 복사되어 두 변수가 같은 객체를 공유합니다.
// 한 변수를 통해 객체를 수정하면 다른 변수에도 영향을 줍니다.

// 출력 결과:
// 21 (동일한 객체를 참조하므로 함께 변경됨)
// 21


// --------------------------------------------------------------------------
// 서로 다른 참조 (다른 신분증)
// --------------------------------------------------------------------------

// 야무2 객체 생성
// isHavingFun 속성: true


// 지니2 객체 생성
// isHavingFun 속성: true


// 야무2와 지니2를 === 연산자로 비교한 결과 출력


// 설명:
// 두 객체는 내용이 같지만, 힙 메모리에 각각 별도로 생성되었습니다.
// 스택에 저장된 주소(참조)가 다르므로 비교 결과는 false입니다.

// 출력 결과:
// false


// --------------------------------------------------------------------------
// 서로 같은 참조 (같은 신분증)
// --------------------------------------------------------------------------

// 야무3 객체 생성
// isHavingFun 속성: true


// 지니3 변수에 야무3 객체 할당 (주소 복사)


// 야무3와 지니3를 === 연산자로 비교한 결과 출력


// 설명:
// 지니3 변수에 야무3의 주소를 그대로 복사했습니다.
// 두 변수가 같은 주소(참조)를 가지고 있으므로 비교 결과는 true입니다.

// 출력 결과:
// true


// --------------------------------------------------------------------------
// 기본 타입 복사 - 독립적인 값
// --------------------------------------------------------------------------

// a 변수에 10 할당


// b 변수에 a 값 복사


// a 변수를 20으로 변경


// a 변수 출력


// b 변수 출력


// 설명:
// 기본 타입은 값이 복사되므로 a를 변경해도 b는 영향을 받지 않습니다.

// 출력 결과:
// 20
// 10


// --------------------------------------------------------------------------
// 객체 타입 복사 - 공유되는 참조
// --------------------------------------------------------------------------

// obj1 객체 생성
// x 속성: 10
// y 속성: 24


// obj2 변수에 obj1 객체 할당 (주소 복사)


// obj1 객체의 x 속성을 40으로 변경


// obj1 객체 출력


// obj2 객체 출력


// 설명:
// 객체는 주소가 복사되므로 obj1을 변경하면 obj2도 함께 변경됩니다.
// 두 변수가 같은 객체를 참조하고 있기 때문입니다.

// 출력 결과:
// { x: 40, y: 24 }
// { x: 40, y: 24 }


// --------------------------------------------------------------------------
// null과 undefined 비교
// --------------------------------------------------------------------------

// null과 undefined를 == 연산자로 비교한 결과 출력


// null과 undefined를 === 연산자로 비교한 결과 출력


// 설명:
// == 연산자는 타입을 자동 변환하므로 null과 undefined를 같다고 판단합니다.
// === 연산자는 타입까지 비교하므로 null과 undefined를 다르다고 판단합니다.

// 출력 결과:
// true
// false


// --------------------------------------------------------------------------
// 핵심!
// --------------------------------------------------------------------------
// 1. 기본 타입은 스택(Stack)에 값 자체가 저장됩니다. (값 복사)
// 2. 객체 타입은 힙(Heap)에 저장되고, 스택에는 주소만 저장됩니다. (주소 복사)
// 3. 기본 타입을 복사하면 값이 복사되어 서로 독립적입니다. (메모지 비유)
// 4. 객체 타입을 복사하면 주소가 복사되어 같은 객체를 공유합니다. (집 주소 비유)
// 5. === 연산자는 스택에 저장된 값을 비교합니다.
// 6. 객체 비교 시 주소(참조)가 같아야 true, 내용이 같아도 주소가 다르면 false입니다.
// 7. 객체를 수정하면 같은 주소를 참조하는 모든 변수에 영향을 줍니다.


// --------------------------------------------------------------------------
// 추가 연습 예제
// --------------------------------------------------------------------------

// 배열도 객체 타입입니다 - 주소 복사 확인

// arr1 배열 생성 [1, 2, 3]


// arr2 변수에 arr1 배열 할당 (주소 복사)


// arr1 배열의 0번 인덱스를 100으로 변경


// arr1 배열 출력


// arr2 배열 출력


// 설명:
// 배열도 객체 타입이므로 주소가 복사됩니다.
// arr1을 변경하면 arr2도 함께 변경됩니다.

// 출력 결과:
// [100, 2, 3]
// [100, 2, 3]


// 함수도 객체 타입입니다

// greet 함수 선언
// 매개변수: name
// 기능: 'Hello, [name]!' 반환


// greet2 변수에 greet 함수 할당 (주소 복사)


// greet 함수 호출 ('Alice' 전달) 및 결과 출력


// greet2 함수 호출 ('Bob' 전달) 및 결과 출력


// greet와 greet2를 === 연산자로 비교한 결과 출력


// 설명:
// 함수도 객체 타입이므로 주소가 복사됩니다.
// greet와 greet2는 같은 함수를 참조하므로 === 비교 결과는 true입니다.

// 출력 결과:
// 'Hello, Alice!'
// 'Hello, Bob!'
// true


// 독립적인 객체 만들기 - 스프레드 연산자 사용

// original 객체 생성
// name 속성: '철수'
// age 속성: 25


// copy 변수에 original 객체를 스프레드 연산자로 복사
// const copy = { ...original }


// copy 객체의 age 속성을 30으로 변경


// original 객체 출력


// copy 객체 출력


// 설명:
// 스프레드 연산자(...)를 사용하면 객체의 내용을 복사하여 새로운 객체를 만듭니다.
// 이 경우 두 객체는 서로 다른 주소를 가지므로 독립적입니다.

// 출력 결과:
// { name: '철수', age: 25 } (원본은 변경되지 않음)
// { name: '철수', age: 30 }
